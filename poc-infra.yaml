AWSTemplateFormatVersion: '2010-09-09'
Description: |
  AWS CloudFormation Template for a two-tier Proof-of-Concept (PoC) architecture.
  This template deploys a VPC with two public and two private subnets, an EC2 Web Instance
  (Public Subnet) running a Python backend, and an RDS PostgreSQL instance (in private tier).
  Includes CodeDeploy Agent installation for CI/CD setup.

Parameters:
  VpcCidr:
    Type: String
    Default: 10.0.0.0/16
    Description: CIDR block for the VPC.
  
  # --- Network Configuration Parameters ---
  PublicSubnet1Cidr:
    Type: String
    Default: 10.0.1.0/24
  PublicSubnet2Cidr:
    Type: String
    Default: 10.0.2.0/24
  PrivateSubnet1Cidr:
    Type: String
    Default: 10.0.11.0/24
  PrivateSubnet2Cidr:
    Type: String
    Default: 10.0.12.0/24

  # --- EC2 Parameters ---
  InstanceType:
    Type: String
    Default: t3.micro
  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2'
  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair to enable SSH access.

  # --- RDS Parameters ---
  DBInstanceIdentifier:
    Type: String
    Default: app-poc-db
  DBUsername:
    Type: String
    Default: masteruser
  DBPassword:
    Type: String
    NoEcho: true
    Description: Master password for the database.
  DBInstanceType:
    Type: String
    Default: db.t3.micro
  DBAllocatedStorage:
    Type: Number
    Default: 20
  DBName:
    Type: String
    Default: pocdb

Mappings:
  RegionMap:
    us-east-1:
      AZ1: us-east-1a
      AZ2: us-east-1b

Resources:
  # --- VPC ---
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-VPC"

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-IGW"

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  # --- Subnets ---
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet1Cidr
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Public-1"

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet2Cidr
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Public-2"

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet1Cidr
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Private-1"

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet2Cidr
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Private-2"

  # --- NAT Gateway ---
  NatGatewayEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  NatGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-NAT-GW"

  # --- Route Tables ---
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Public-RT"

  PublicRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Private-RT"

  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable

  # --- Security Groups ---
  WebSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VPC
      GroupDescription: Allow HTTP and SSH
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Web-SG"

  DBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VPC
      GroupDescription: Allow DB access only from Web EC2
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref WebSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-DB-SG"

  # --- IAM Role ---
  WebInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforAWSCodeDeploy

  WebInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref WebInstanceRole

  # --- EC2 Instance ---
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !Ref LatestAmiId
      KeyName: !Ref KeyName
      SubnetId: !Ref PublicSubnet1
      SecurityGroupIds:
        - !Ref WebSecurityGroup
      AssociatePublicIpAddress: true
      IamInstanceProfile: !Ref WebInstanceProfile
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-WebServer"
      UserData:
        Fn::Base64:
          Fn::Sub:
            - |
              #!/bin/bash -xe
              
              # 1. Install necessary dependencies (needed before CodeDeploy takes over)
              yum update -y
              amazon-linux-extras install python3.8 -y
              yum install -y postgresql-devel gcc ruby wget
              pip3 install flask gunicorn psycopg2-binary passlib
              
              # --- Install CodeDeploy Agent (CRITICAL for CI/CD) ---
              wget https://aws-codedeploy-${AWS::Region}.s3.${AWS::Region}.amazonaws.com/latest/install
              chmod +x install && ./install auto
              
              # 2. Set up environment variables for the DB connection (uses placeholders from the map below)
              export DB_ENDPOINT="${DBEndpoint}"
              export DB_USERNAME="${DBUsername}"
              export DB_PASSWORD="${DBPassword}"
              export DB_NAME="${DBName}"
              export DB_PORT="${DBPort}"
              echo "DB env vars set successfully"
              
              # 3. Create the Python backend application (app.py)
              cat << 'EOF' > /home/ec2-user/app.py
              import os
              import json
              import psycopg2
              from flask import Flask, request, jsonify
              from passlib.hash import pbkdf2_sha256

              # --- Configuration from Environment Variables ---
              DB_ENDPOINT = os.environ.get("DB_ENDPOINT")
              DB_NAME = os.environ.get("DB_NAME")
              DB_USER = os.environ.get("DB_USERNAME")
              DB_PASS = os.environ.get("DB_PASSWORD")
              DB_PORT = os.environ.get("DB_PORT")
              
              app = Flask(__name__)

              def get_db_connection():
                  """Establishes a connection to the PostgreSQL database."""
                  try:
                      conn = psycopg2.connect(
                          host=DB_ENDPOINT,
                          database=DB_NAME,
                          user=DB_USER,
                          password=DB_PASS,
                          port=DB_PORT
                      )
                      return conn
                  except Exception as e:
                      print(f"Database connection error: {e}")
                      return None

              def initialize_db():
                  """Creates the 'users' table if it does not exist."""
                  conn = get_db_connection()
                  if conn:
                      try:
                          cursor = conn.cursor()
                          # Using UUID for id is standard, but simplified here for PoC
                          cursor.execute("""
                              CREATE TABLE IF NOT EXISTS users (
                                  id SERIAL PRIMARY KEY,
                                  email VARCHAR(255) UNIQUE NOT NULL,
                                  password_hash VARCHAR(255) NOT NULL
                              );
                          """)
                          conn.commit()
                          cursor.close()
                      except Exception as e:
                          print(f"Database initialization error: {e}")
                      finally:
                          conn.close()

              @app.route('/signup', methods=['POST'])
              def signup():
                  data = request.json
                  email = data.get('email')
                  password = data.get('password')

                  if not email or not password:
                      return jsonify({"error": "Email and password required"}), 400

                  # Hash the password securely
                  password_hash = pbkdf2_sha256.hash(password)
                  
                  conn = get_db_connection()
                  if not conn:
                      return jsonify({"error": "Database unavailable"}), 503

                  try:
                      cursor = conn.cursor()
                      cursor.execute(
                          "INSERT INTO users (email, password_hash) VALUES (%s, %s)",
                          (email, password_hash)
                      )
                      conn.commit()
                      cursor.close()
                      return jsonify({"message": "User created successfully"}), 201
                  except psycopg2.errors.UniqueViolation:
                      conn.rollback()
                      return jsonify({"error": "User already exists"}), 409
                  except Exception as e:
                      conn.rollback()
                      print(f"Signup error: {e}")
                      return jsonify({"error": "Internal server error"}), 500
                  finally:
                      conn.close()

              @app.route('/login', methods=['POST'])
              def login():
                  data = request.json
                  email = data.get('email')
                  password = data.get('password')

                  conn = get_db_connection()
                  if not conn:
                      return jsonify({"error": "Database unavailable"}), 503
                  
                  user_data = None
                  try:
                      cursor = conn.cursor()
                      cursor.execute("SELECT password_hash FROM users WHERE email = %s", (email,))
                      user_data = cursor.fetchone()
                      cursor.close()
                  except Exception as e:
                      print(f"Login database error: {e}")
                      return jsonify({"error": "Internal server error"}), 500
                  finally:
                      conn.close()

                  if user_data:
                      stored_hash = user_data[0]
                      # Verify the password against the stored hash
                      if pbkdf2_sha256.verify(password, stored_hash):
                          return jsonify({"message": f"Login successful for {email}"}), 200
                      else:
                          return jsonify({"error": "Invalid credentials"}), 401
                      
                  else:
                      return jsonify({"error": "Invalid credentials"}), 401


              # Serve the static HTML frontend
              @app.route('/')
              def serve_frontend():
                  try:
                      # NOTE: The index.html needs to be placed in the same directory by the script
                      with open('index.html', 'r') as f:
                          return f.read()
                  except FileNotFoundError:
                      return "Frontend file not found. Please ensure index.html is in /home/ec2-user/", 500

              # Initialize the database table structure when the app starts
              initialize_db()
              
              if __name__ == '__main__':
                  app.run(host='0.0.0.0', port=5000)

              EOF
              
              # 4. Copy the frontend code (index.html) into the app directory
              # NOTE: The CodeDeploy pipeline will overwrite this with the GitHub version later.
              cat << 'FRONTEND_EOF' > /home/ec2-user/index.html
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>PoC Web App: Login & Signup</title>
                  <!-- Load Tailwind CSS for quick, professional styling -->
                  <script src="https://cdn.tailwindcss.com"></script>
                  <style>
                      body {
                          font-family: 'Inter', sans-serif;
                          background-color: #f7f9fb;
                      }
                  </style>
              </head>
              <body class="flex items-center justify-center min-h-screen p-4">
                  <div class="w-full max-w-md bg-white p-8 rounded-xl shadow-2xl border border-gray-100">
                      <div class="flex justify-center mb-6">
                          <h1 id="title" class="text-3xl font-extrabold text-indigo-700">Login</h1>
                      </div>

                      <div id="message-box" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
                          <span class="block sm:inline" id="alert-text"></span>
                      </div>

                      <form id="auth-form" class="space-y-6">
                          <div>
                              <label for="email" class="block text-sm font-medium text-gray-700">Email Address</label>
                              <input type="email" id="email" name="email" required
                                     class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
                          </div>

                          <div>
                              <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                              <input type="password" id="password" name="password" required minlength="8"
                                     class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
                              <p class="text-xs text-gray-500 mt-1">Minimum 8 characters.</p>
                          </div>

                          <div>
                              <button type="submit" id="submit-button"
                                      class="w-full flex justify-center py-2 px-4 border border-transparent rounded-lg shadow-lg text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-300 ease-in-out">
                                  Log In
                              </button>
                          </div>
                      </form>

                      <div class="mt-6 text-center">
                          <button id="toggle-button" class="text-sm text-indigo-600 hover:text-indigo-800 transition duration-150 ease-in-out">
                              Need an account? Sign Up
                          </button>
                      </div>
                  </div>

                  <script>
                      const form = document.getElementById('auth-form');
                      const title = document.getElementById('title');
                      const submitButton = document.getElementById('submit-button');
                      const toggleButton = document.getElementById('toggle-button');
                      const messageBox = document.getElementById('message-box');
                      const alertText = document.getElementById('alert-text');
                      let isLogin = true;

                      const showMessage = (message, isError = true) => {
                          alertText.textContent = message;
                          messageBox.classList.remove('hidden');
                          messageBox.className = `bg-${isError ? 'red' : 'green'}-100 border border-${isError ? 'red' : 'green'}-400 text-${isError ? 'red' : 'green'}-700 px-4 py-3 rounded mb-4`;
                          setTimeout(() => {
                              messageBox.classList.add('hidden');
                          }, 5000);
                      };

                      const toggleMode = () => {
                          isLogin = !isLogin;
                          title.textContent = isLogin ? 'Login' : 'Sign Up';
                          submitButton.textContent = isLogin ? 'Log In' : 'Create Account';
                          toggleButton.textContent = isLogin ? 'Need an account? Sign Up' : 'Already have an account? Log In';
                      };

                      const handleFormSubmit = async (event) => {
                          event.preventDefault();
                          const email = document.getElementById('email').value;
                          const password = document.getElementById('password').value;

                          const endpoint = isLogin ? '/login' : '/signup';
                          
                          submitButton.disabled = true;
                          submitButton.textContent = isLogin ? 'Processing...' : 'Processing...';

                          try {
                              // The fetch call goes directly to the EC2 instance's port 80
                              const response = await fetch(endpoint, {
                                  method: 'POST',
                                  headers: {
                                      'Content-Type': 'application/json'
                                  },
                                  body: JSON.stringify({ email, password })
                              });

                              const result = await response.json();
                              
                              if (response.ok) {
                                  if (isLogin) {
                                      showMessage(result.message, false);
                                  } else {
                                      showMessage(result.message + " Switching to Login.", false);
                                      toggleMode(); // Switch to login after successful signup
                                  }
                                  form.reset();
                              } else {
                                  showMessage(`[${response.status}] ${result.error || 'Request failed'}`, true);
                              }

                          } catch (error) {
                              console.error("Fetch error:", error);
                              showMessage("Could not connect to the backend server.", true);
                          } finally {
                              submitButton.disabled = false;
                              submitButton.textContent = isLogin ? 'Log In' : 'Create Account';
                          }
                      };

                      toggleButton.addEventListener('click', toggleMode);
                      form.addEventListener('submit', handleFormSubmit);

                      tailwind.config = {
                          theme: {
                              extend: {
                                  fontFamily: {
                                      sans: ['Inter', 'sans-serif'],
                                  },
                              },
                          }
                      }
                  </script>
              </body>
              </html>
              FRONTEND_EOF

              # 5. Start the Gunicorn server on port 80
              # We run the app directly on port 80 using gunicorn for initial bootstrapping.
              # Note: In a real environment, this should be handled by a service manager (e.g., systemd).
              /usr/local/bin/gunicorn3 --bind 0.0.0.0:80 app:app --daemon

              # 6. Set appropriate permissions
              chown -R ec2-user:ec2-user /home/ec2-user
              
              echo "Backend application setup complete and running on port 80." > /tmp/setup_status.txt
            - DBEndpoint: !GetAtt RDSInstance.Endpoint.Address
              DBUsername: !Ref DBUsername
              DBPassword: !Ref DBPassword
              DBName: !Ref DBName
              DBPort: !GetAtt RDSInstance.Endpoint.Port

  # --- RDS ---
  DBSecurityGroupSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnets for RDS
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-DB-SubnetGroup"

  RDSInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceClass: !Ref DBInstanceType
      Engine: postgres
      MasterUsername: !Ref DBUsername
      MasterUserPassword: !Ref DBPassword
      DBName: !Ref DBName
      AllocatedStorage: !Ref DBAllocatedStorage
      DBSubnetGroupName: !Ref DBSecurityGroupSubnetGroup
      VPCSecurityGroups:
        - !Ref DBSecurityGroup
      MultiAZ: false
      PubliclyAccessible: false

Outputs:
  VPCId:
    Description: VPC ID
    Value: !Ref VPC
  WebInstancePublicIP:
    Description: Public IP of the EC2 instance
    Value: !GetAtt WebServer.PublicIp
  DBEndpoint:
    Description: RDS Endpoint
    Value: !GetAtt RDSInstance.Endpoint.Address
  DBPort:
    Description: RDS Port
    Value: !GetAtt RDSInstance.Endpoint.Port
